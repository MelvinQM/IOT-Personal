## 2. Bluetooth (BLE)
To use Bluetooth on a ESP32/ESP32-S3 the Arduino core library BLE was used. The header can be included through the arduino core.

### 2.1 BLE Server
For more information about the workings of see the [Technical documentation](./technical_documentation.md##4-bluetooth-ble).

For the creation of a BLE server the following headers must be included.
```c++
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
```

**Initialization**:

To initialize the BLE server and to set up the service and characteristic.
```c++
BLEDevice::init("ESP32 Bluetooth server");
pServer = BLEDevice::createServer();
BLEService *pService = pServer->createService(SERVICE_UUID);

// Allow read and write
pCharacteristic = pService->createCharacteristic(
                                CHARACTERISTIC_UUID, BLECharacteristic::PROPERTY_READ | 
                                BLECharacteristic::PROPERTY_WRITE
                            );
```
<br>

**Callbacks**

To handle any incoming messages from clients a Characteristic callback must be assigned to the server.
```c++
class WriteCallback : public BLECharacteristicCallbacks {
    /**
     * Rest of code ...
    **/

    void onWrite(BLECharacteristic *pCharacteristic) {
        // Get the characteristic value from the client
        std::string value = pCharacteristic->getValue();

        // Deserialize the JSON data
        JsonDocument doc;
        DeserializationError error = deserializeJson(doc, value);

        if (error) {
            Serial.print("Failed to parse JSON: ");
            Serial.println(error.c_str());
            return;
        }
        
        // Store data in servers gyrodata
        server->gyroData = {doc["x"], doc["y"]};
    }
};  
```
To then assign this callback to the server
```c++
pCharacteristic->setCallbacks(new WriteCallback(this));    
```
<br>

The server callbacks notify the user of connections and disconnections. It also stores if a device is currently connected.
```c++
class ServerCallbacks : public BLEServerCallbacks {
    // Called when a device connects.
    void onConnect(BLEServer *pServer) {
        Serial.println("BLE: Device connected");
        deviceConnected = true;
    };

    // Called when a device disconnects.
    void onDisconnect(BLEServer *pServer) {
        Serial.println("BLE: Device disconnected");
        deviceConnected = false;
    }
};
```
To then assign this callback to the server
```c++
pServer->setCallbacks(new ServerCallbacks());
```
<br>

**Starting service and advertising**:

Finally, starting the service through the use of the start() function and enabling advertising to allow the client to connect and send data to the server.
```c++
pService->start();

BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
pAdvertising->addServiceUUID(SERVICE_UUID);
pAdvertising->setScanResponse(true);

BLEDevice::startAdvertising();
```
<br>

### 2.2 BLE Client
To create a BLE client the following headers must be included.
```c++
#include <BLEDevice.h>
```
**Initialization**:

The device is initialized to use BLE and a scan is done to find all bluetooth devices in the area
```c++
  BLEDevice::init("Client Name");
  BLEScan *pBLEScan = BLEDevice::getScan();

  pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
  pBLEScan->setInterval(1349);
  pBLEScan->setWindow(449);
  pBLEScan->setActiveScan(true);
  pBLEScan->start(5, false);
```

**Connecting**:

To connect to the server first a client must be created. This client can then look for specific service/chracteristic UUID's to see if the correct server was found.
```c++
BLEClient *pClient = BLEDevice::createClient();
pClient->setClientCallbacks(new MyClientCallback());

// Connect to the BLE Server.
pClient->connect(myDevice);

// Set client to request maximum MTU from server
pClient->setMTU(517);  
```

**Obtaining reference to service**:

```c++
// Obtain a reference to the service we are after in the remote BLE server.
BLERemoteService *pRemoteService = pClient->getService(serviceUUID);
```

**Obtaining reference to characteristic**:

```c++
// Obtain a reference to the characteristic in the service of the remote BLE server.
pRemoteCharacteristic = pRemoteService->getCharacteristic(charUUID);
```

**Callbacks**:

A callback can be made to activate on every BLEServer found by looking at the serviceUUID of the current looked at server thats advertising. We can determine if we found the Server we are looking for.
```c++
class MyAdvertisedDeviceCallbacks : public BLEAdvertisedDeviceCallbacks {
  //Called for each advertising BLE server.
  void onResult(BLEAdvertisedDevice advertisedDevice) {
    if (advertisedDevice.haveServiceUUID() && advertisedDevice.isAdvertisingService(serviceUUID)) {
      BLEDevice::getScan()->stop();
      myDevice = new BLEAdvertisedDevice(advertisedDevice);
      doConnect = true;
      doScan = true;
    }
  }
};
```

**Main loop**:

When the client is properly initialized the client will attempt to connect to the server once and if a connection is established will start periodically sending gyroscopic data.
```c++
// Try to connect once
if (doConnect == true) 
{
    if (connectToServer()) {
        Serial.println("We are now connected to the BLE Server.");
    } else {
        Serial.println("We have failed to connect to the server; there is nothing more we will do.");
    }
    doConnect = false;
}

// When connection is established send data
if (connected) 
{
    String data = SendGyroData();
    Serial.println("Setting new characteristic value to \"" + data + "\"");
    pRemoteCharacteristic->writeValue(data.c_str(), data.length());
} else if (doScan) 
{
    BLEDevice::getScan()->start(0);
}
```


<!-- In hopes to answer the sub question "What are some existing motion controller designs on the market?" I looked into some products that already exists.
<div style="display: flex; align-items: center;">
    <div style="flex: 1;">
        <img src="/../assets/images/duckhuntbox.jpg" alt="cursorconcept" style="max-width: 100%;">
    </div>
    <div style="flex: 1;">
        <h4>Duck Hunt Light Gun</h4>
        <p>Duck hunt was a game for the NES which made use of a so called light gun to shoot flying by ducks on screen. The game was released back in April of 1984 in Japan and later in October 1985 in America. Duck hunt's gameplay involved shooting ducks and clay pigeons. The player got 3 attempts per round to get a certain number of hits or get a gameover. </p>
        <p><span style="font-weight: bold;">Technical Details:</span>The game worked by leveraging the CRT tv technology of the time. The gun consists of a trigger and a photodiode(light sensor). When the trigger is pressed the screen will go black for one frame except for the duck. The duck would light up white causing the light sensor "if aimed correctly" to sense the duck and register it as a hit.</p>
        <p style="font-weight: bold;">Keypoints: Screen flicker, Light sensor</p>
    </div>
</div>

<br>
<hr>

<div style="display: flex; align-items: center;">
  <div style="display: flex; flex-direction: column; justify-content: center; align-items: left; width: 50%;">
      <img src="/../assets/images/wii-controller.jpg" alt="wii-controller" style="width: 50%;margin-bottom: 5%;">
      <img src="/../assets/images/wiimotionplus.jpg" alt="wiimotionplus" style="width: 50%;">
  </div>
  <div style="flex: 1;">
    <h4>Wii Motion Controller</h4>
    <p>The wii motion controller is the signature controller for the Nintendo Wii which released worldwide in 2006. The Wii controller was used for motion control games such as Wii Sports and other wii games. It allowed a digital cursor to be shown on screen based on the angle you pointed the controller at a sensor bar. It also allowed for motion controls such as registering movements such as; shaking, swinging and more.</p>
    <p><span style="font-weight: bold;">Technical Details:</span> Using 2 different systems make motion controls possible; the linear accelerometer and infrared sensor. The linear accelerometer measures the acceleration of gravity when tilted it doesnt receive the full force of gravity onto the sensor allowing to measure the tilt of the controller. It does this in 3 axis to sense the orientation of the wii remote. Later in the lifespan of the Wii the wii motion plus was introduced. This was an optional addition that cold be plugged into the wii controller. This device has a gyroscope that accomplishes a similair result as the accelerometer that is more accurate. The position of the controller relative to the screen is done using the infrared sensors. The Wii is fitted with a infrared light source known at the sensor bar. This bar has 5 infrared lights on both sides. Measuring the position of the two sources on the sensor allows the controller to be able to determine the angle the light is coming from.</p>
    <p style="font-weight: bold;">Keypoints: Accelerometer, Gyroscope, Infrared Sensor</p>
  </div>
</div>

After looking into some techniques for desiging a motion controlled game console. A decision was made to use the MPU6050 which allows for both gyroscopic and accelerometer angles. This allows the controller to be able to control a digital cursor by rotating on the vertical and horizontal axis. -->


#### 2.2.1 UDP Connection through SoftAccessPoint
To establish the connection between console and controller the SoftAP needs to be initialized on the console first. Using the local ip, gateway ip and a network mask the access point is intialized. A hostname is then specified allowing the controller to find the AP.

The controller will attempt to connect to the AP and begin to send UDP packets containing the following json formatted data:
    jsonDoc["method"] = CONTROLLER_AXIS_DATA_METHOD;
    jsonDoc["data"]["gX"] = gData.x;
    jsonDoc["data"]["gY"] = gData.y;
    jsonDoc["data"]["jX"] = jData.x;
    jsonDoc["data"]["jY"] = jData.y;

AxisData:
```json
{
    "method": "axisData",
    "data": {
        "gX": 0.0,
        "gY": 0.0,
        "jX": 0.0,
        "gX": 0.0
    }
}
```

Upon clicking either the joystick or the trigger a packet will also be sent:

**Joystick Clicked**:
```json
{
    "method": "joystickClick",
}
```

**Trigger Pressed**:
```json
{
    "method": "trigger",
}
```

The console will receive these packets and store them in an instance of the `GameDataModel` class. This class holds all data and is created to serve as the middle man between the `SpriteRenderer` class and the `Connections` class